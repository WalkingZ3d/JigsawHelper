import javax.imageio.ImageIO;
import javax.swing.*;

import java.awt.image.*;
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.awt.Color;

public class LocationAlgorithm extends JFrame {

    static String finishedImage;
    static String finishedImageName;
    static int[][] finishedPixelsArrayDouble;

    static String pieceImage;
    static String pieceImageName;
    static Boolean pieceEdgesFlag;
    static int[][] piecePixelsArrayDouble;

    static int[][][] finishedPixelsArrayTriple;
    static int[][][] piecePixelsArrayTriple;

    static Map<int[], Double> pieceLocation;

    static double meanSquareErrorThreshold;

    static int[] positionOfPiece;
    static int[] positionOfPiece2;
    static int[] positionOfPiece3;
    static int[] positionOfPiece4;
    static int[] positionOfPiece5;
    static int[] positionOfPiece6;
    static int[] positionOfPiece7;
    static int[] positionOfPiece8;
    static int[] positionOfPiece9;
    static int[] positionOfPiece10;

    static ArrayList<Integer> xCoordsArrayList = new ArrayList<Integer>();
    static ArrayList<Integer> yCoordsArrayList = new ArrayList<Integer>();

    public LocationAlgorithm() {

    }

    // launch method supplied with 2 image paths and returning 1d array of locations of piece by mse
    static LinkedHashMap<int[], Double> launch(String finishedImage, String pieceImage) throws IOException {
        pieceEdgesFlag = false;

        // calling the sobelDetector method on the piece and the finished image to get the greyscale pixel array and the edge flag
        finishedPixelsArrayDouble = sobelDetector(finishedImage, finishedImageName, false, finishedPixelsArrayDouble);
        piecePixelsArrayDouble = sobelDetector(pieceImage, pieceImageName, true, piecePixelsArrayDouble);

        System.out.println(pieceEdgesFlag);

        // if the edge detect flag is true for the piece, use the greyscale image, else use the colour image
        if (pieceEdgesFlag == true) {
            // the threshold detrmines what is counted as a match for location - if it is below the threshold
            meanSquareErrorThreshold = 0.75;
            pieceLocation = searchImageGreyScale(finishedPixelsArrayDouble, piecePixelsArrayDouble);
        } else {
            // since the edge flag is false there is no edge and so a colour image must be used, generated by calling the getColourArray method
            finishedPixelsArrayTriple = getColourArray(finishedImage, finishedPixelsArrayTriple);
            piecePixelsArrayTriple = getColourArray(pieceImage, piecePixelsArrayTriple);
            meanSquareErrorThreshold = 0.25;
            pieceLocation = searchImageColour(finishedPixelsArrayTriple, piecePixelsArrayTriple);
        }

        // LinkedHasMap to store the possible locations of the puzzle piece within the finished image
        LinkedHashMap<int[], Double> sortedMap = new LinkedHashMap<>();

        // putting the locations generated into the map by mse 
        pieceLocation.entrySet()
                .stream()
                .sorted(Map.Entry.comparingByValue())
                .forEachOrdered(x -> sortedMap.put(x.getKey(), x.getValue()));
        
        
        return sortedMap;
    }

 
    // method for edge detection, returns the greyscale 2d array of pixels from image
    public static int[][] sobelDetector(String imagePath, String imageName, Boolean isPiece, int[][] pixels)
            throws IOException {

        BufferedImage myPicture = ImageIO.read(new File(imagePath));

        int widthOfPic = myPicture.getWidth();
        int heightOfPic = myPicture.getHeight();

        // CREATES 2D ARRAY CONTAINING PIXELS FROM GIVEN IMAGE, SIZE SET BY IMAGE SIZE
        pixels = new int[widthOfPic][heightOfPic];

        int gradientMaxValue = -1;

        // NESTED LOOPS ITERATE THROUGH BOTH ROWS AND COLUMNS OF 2D ARRAY SIMULTANEOUSLY
        for (int i = 1; i < widthOfPic - 1; i++) {
            for (int j = 1; j < heightOfPic - 1; j++) {

                // AQUIRE THE RGB VALUE FOR EACH PIXEL IN POSITION IN 2D ARRAY OF IMAGE PIXELS
                // EACH R, G, B VALUE IS AQUIRED AND ADDED (ALTERNATIVE WOULD BE CHANGING TO
                // GREYSCALE)
                int pixelRow0Col0 = myPicture.getRGB(i - 1, j - 1);
                int pixelRow0Col0R = (pixelRow0Col0 >> 16) & 0xff;
                int pixelRow0Col0G = (pixelRow0Col0 >> 8) & 0xff;
                int pixelRow0Col0B = (pixelRow0Col0) & 0xff;
                int pixelRow0Col0RGB = (pixelRow0Col0R + pixelRow0Col0G + pixelRow0Col0B) / 3;

                int pixelRow0Col1 = myPicture.getRGB(i - 1, j);
                int pixelRow0Col1R = (pixelRow0Col1 >> 16) & 0xff;
                int pixelRow0Col1G = (pixelRow0Col1 >> 8) & 0xff;
                int pixelRow0Col1B = (pixelRow0Col1) & 0xff;
                int pixelRow0Col1RGB = (pixelRow0Col1R + pixelRow0Col1G + pixelRow0Col1B) / 3;

                int pixelRow0Col2 = myPicture.getRGB(i - 1, j + 1);
                int pixelRow0Col2R = (pixelRow0Col2 >> 16) & 0xff;
                int pixelRow0Col2G = (pixelRow0Col2 >> 8) & 0xff;
                int pixelRow0Col2B = (pixelRow0Col2) & 0xff;
                int pixelRow0Col2RGB = (pixelRow0Col2R + pixelRow0Col2G + pixelRow0Col2B) / 3;

                int pixelRow1Col0 = myPicture.getRGB(i, j - 1);
                int pixelRow1Col0R = (pixelRow1Col0 >> 16) & 0xff;
                int pixelRow1Col0G = (pixelRow1Col0 >> 8) & 0xff;
                int pixelRow1Col0B = (pixelRow1Col0) & 0xff;
                int pixelRow1Col0RGB = (pixelRow1Col0R + pixelRow1Col0G + pixelRow1Col0B) / 3;

                int pixelRow1Col1 = myPicture.getRGB(i, j);
                int pixelRow1Col1R = (pixelRow1Col1 >> 16) & 0xff;
                int pixelRow1Col1G = (pixelRow1Col1 >> 8) & 0xff;
                int pixelRow1Col1B = (pixelRow0Col0) & 0xff;
                int pixelRow1Col1RGB = (pixelRow1Col1R + pixelRow1Col1G + pixelRow1Col1B) / 3;

                int pixelRow1Col2 = myPicture.getRGB(i, j + 1);
                int pixelRow1Col2R = (pixelRow1Col2 >> 16) & 0xff;
                int pixelRow1Col2G = (pixelRow1Col2 >> 8) & 0xff;
                int pixelRow1Col2B = (pixelRow1Col2) & 0xff;
                int pixelRow1Col2RGB = (pixelRow1Col2R + pixelRow1Col2G + pixelRow1Col2B) / 3;

                int pixelRow2Col0 = myPicture.getRGB(i + 1, j - 1);
                int pixelRow2Col0R = (pixelRow2Col0 >> 16) & 0xff;
                int pixelRow2Col0G = (pixelRow2Col0 >> 8) & 0xff;
                int pixelRow2Col0B = (pixelRow2Col0) & 0xff;
                int pixelRow2Col0RGB = (pixelRow2Col0R + pixelRow2Col0G + pixelRow2Col0B) / 3;

                int pixelRow2Col1 = myPicture.getRGB(i + 1, j);
                int pixelRow2Col1R = (pixelRow2Col1 >> 16) & 0xff;
                int pixelRow2Col1G = (pixelRow2Col1 >> 8) & 0xff;
                int pixelRow2Col1B = (pixelRow2Col1) & 0xff;
                int pixelRow2Col1RGB = (pixelRow2Col1R + pixelRow2Col1G + pixelRow2Col1B) / 3;

                int pixelRow2Col2 = myPicture.getRGB(i + 1, j + 1);
                int pixelRow2Col2R = (pixelRow2Col2 >> 16) & 0xff;
                int pixelRow2Col2G = (pixelRow2Col2 >> 8) & 0xff;
                int pixelRow2Col2B = (pixelRow2Col2) & 0xff;
                int pixelRow2Col2RGB = (pixelRow2Col2R + pixelRow2Col2G + pixelRow2Col2B) / 3;

                // SOBEL EDGE DETETCTION OPERATOR HORIZONTAL (ROW) :
                // { -1, -2, -1 }
                // { 0, 0, 0 }
                // { 1, 2, 1 }
                int sobelHorizontal = ((-1 * pixelRow0Col0RGB) + (-2 * pixelRow0Col1RGB) + (-1 * pixelRow0Col2RGB))
                        + ((0 * pixelRow1Col0RGB) + (0 * pixelRow1Col1RGB) + (0 * pixelRow1Col2RGB))
                        + ((1 * pixelRow2Col0RGB) + (2 * pixelRow2Col1RGB) + (1 * pixelRow2Col2RGB));

                // SOBEL EDGE DETETCTION OPERATOR VERTICAL (COLUMNS) :
                // { -1, 0, 1 }
                // { -2, 0, 2 }
                // { -1, 0, 1 }
                int sobelVertical = ((-1 * pixelRow0Col0RGB) + (0 * pixelRow0Col1RGB) + (1 * pixelRow0Col2RGB))
                        + ((-2 * pixelRow1Col0RGB) + (0 * pixelRow1Col1RGB) + (2 * pixelRow1Col2RGB))
                        + ((-1 * pixelRow2Col0RGB) + (0 * pixelRow2Col1RGB) + (1 * pixelRow2Col2RGB));

                // THE GRADIENT WILL NOT ALWAYS BE A ROUND NUMBER, SO IT IS TYPE CAST INTO AN
                // INTEGER
                double gradientDouble = Math
                        .sqrt((sobelHorizontal * sobelHorizontal) + (sobelVertical * sobelVertical));
                int gradient = (int) gradientDouble;

                if (gradientMaxValue < gradient) {
                    gradientMaxValue = gradient;
                }

                // ADDING THE GRADIENTS TO THE 2D PIXEL ARRAY
                pixels[i][j] = gradient;
            }
        }

        // only works when the image is of a piece and not the finished jigsaw
        if (isPiece == true) {

            // an edge causes a high number in the array, flag is determined by this threshold
            int minRequiredToFlag = 100;

            int largestNumFound = 0;

            for (int i = 1; i < widthOfPic - 1; i++) {
                for (int j = 1; j < heightOfPic - 1; j++) {
                    if (pixels[i][j] >= 100) {
                        largestNumFound = pixels[i][j];
                    }
                }
            }

            // if threshold is met, set the flag as true
            if (largestNumFound > minRequiredToFlag) {
                pieceEdgesFlag = true;
            }


        }
        // returns 2d array of greyscale pixels of image
        return pixels;

    }

    // method to search through the greyscale 2d array and return a map of each location alongisde the mse 
    public static Map<int[], Double> searchImageGreyScale(int[][] imageArray, int[][] subImageArray) {
        int subImageYAxis = subImageArray[0].length;
        int subImageXAxis = subImageArray.length;

        // Map to store location and score, where score is mse
        Map<int[], Double> pieceLocationsAndScores = new HashMap<>();

        // searching through the entire array
        for (int x = 0; x < imageArray.length - subImageXAxis; x++) {
            for (int y = 0; y < imageArray[0].length - subImageYAxis; y++) {

                // Make a cut of the full image, the size of the jigsaw piece
                int[][] comparatorArray = new int[subImageXAxis][subImageYAxis];
                for (int i = 0; i < subImageXAxis - 1; i++) {
                    comparatorArray[i] = Arrays.copyOfRange(imageArray[x + i], y, y + subImageYAxis);
                }

                // Check if the cut and the jigsaw piece are equal (deep equals comapres values,
                // just equals compares objects)
                Double mse = meanSquaredErrorGreyScale(comparatorArray, subImageArray);

                if (mse < meanSquareErrorThreshold) {
                    pieceLocationsAndScores.put(new int[] { x, y }, mse);
                }

            }

        }
        return pieceLocationsAndScores;
    }

    // mean squared error for greyscale 2d array 
    public static double meanSquaredErrorGreyScale(int[][] imageArray, int[][] comparatorArray) {
        int imageXAxis = imageArray.length;
        int imageYAxis = imageArray[0].length;
        double error = 0.0;
        for (int i = 0; i < imageXAxis - 1; i++) {
            for (int j = 0; j < imageYAxis - 1; j++) {
                error += (imageArray[i][j] - comparatorArray[i][j]);
            }
        }
         // squaring error and dividing by image x * y axis
        return Math.pow(error, 2) / (imageXAxis * imageYAxis);
    }

    // method returns the 3d array of pixels [r][g][b] of the image
    public static int[][][] getColourArray(String imagePath, int[][][] pixels) throws IOException {

        BufferedImage myPicture = ImageIO.read(new File(imagePath));

        int widthOfPic = myPicture.getWidth();
        int heightOfPic = myPicture.getHeight();

        pixels = new int[widthOfPic][heightOfPic][3];

        // iterate through 3d array and populate with the value of the pixels for each colour
        for (int i = 0; i < pixels.length; i++)
            for (int j = 0; j < pixels[0].length; j++) {

                Color pixelColor = new Color(myPicture.getRGB(i, j));
                pixels[i][j][0] = pixelColor.getRed();
                pixels[i][j][1] = pixelColor.getGreen();
                pixels[i][j][2] = pixelColor.getBlue();
            }

        return pixels;
    }

    // method to search through the colour 3d array and return a map of each location alongisde the mse 
    public static Map<int[], Double> searchImageColour(int[][][] imageArray, int[][][] subImageArray) {
        int subImageYAxis = subImageArray[0].length;
        int subImageXAxis = subImageArray.length;
        Map<int[], Double> pieceLocationsAndScores = new HashMap<>();

        for (int x = 0; x < imageArray.length - subImageXAxis; x++) {
            for (int y = 0; y < imageArray[0].length - subImageYAxis; y++) {

                // Make a cut of the full image, the size of the jigsaw piece
                int[][][] comparatorArray = new int[subImageXAxis][subImageYAxis][3];
                for (int i = 0; i < subImageXAxis - 1; i++) {
                    comparatorArray[i] = Arrays.copyOfRange(imageArray[x + i], y, y + subImageYAxis);
                }

                // Check if the cut and the jigsaw piece are equal (deep equals comapres values,
                // just equals compares objects)
                Double mse = meanSqaureErrorColour(comparatorArray, subImageArray);

                if (mse < meanSquareErrorThreshold) {
                    pieceLocationsAndScores.put(new int[] { x, y }, mse);
                }
            }

        }
        return pieceLocationsAndScores;
    }

    // mean squared error for colour 3d array 
    public static double meanSqaureErrorColour(int[][][] imageArray, int[][][] comparatorArray) {

        int imageXAxis = imageArray.length;
        int imageYAxis = imageArray[0].length;
        double error = 0.0;
        for (int i = 0; i < imageXAxis - 1; i++) {
            for (int j = 0; j < imageYAxis - 1; j++) {
                error += (imageArray[i][j][0] - comparatorArray[i][j][0])
                        + (imageArray[i][j][1] - comparatorArray[i][j][1])
                        + (imageArray[i][j][2] - comparatorArray[i][j][2]);
            }
        }
        // squaring error and dividing by image x * y axis
        return Math.pow(error, 2) / (imageXAxis * imageYAxis);
    }

}
